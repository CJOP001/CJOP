{"version":3,"names":[],"sources":["helperTypes.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/*\nThis file is a legacy remainder of manual types from react-native-reanimated.d.ts file. \nI wasn't able to get rid of all of them from the code. \nThey should be treated as a temporary solution\nuntil time comes to refactor the code and get necessary types right. \nThis will not be easy though! \n*/\n\nimport type {\n  ColorValue,\n  StyleProp,\n  TransformsStyle as RNTransformsStyle,\n} from 'react-native';\nimport type {\n  AnimatableValue,\n  BaseAnimationBuilder,\n  EntryExitAnimationFunction,\n  LayoutAnimationFunction,\n  SharedValue,\n} from '.';\nimport type { ReanimatedKeyframe } from './layoutReanimation/animationBuilder/Keyframe';\nimport type { SharedTransition } from './layoutReanimation/sharedTransitions';\nimport type { DependencyList } from './hook/commonTypes';\n\nexport type Adaptable<T> =\n  | T\n  | ReadonlyArray<T | ReadonlyArray<T>>\n  | SharedValue<T>;\n\nexport type AdaptTransforms<T> = {\n  [P in keyof T]: Adaptable<T[P]>;\n};\n\ntype TransformsStyle = Pick<RNTransformsStyle, 'transform'>;\n\nexport type TransformStyleTypes = TransformsStyle['transform'] extends\n  | readonly (infer T)[]\n  | string\n  | undefined\n  ? T\n  : never;\nexport type AnimatedTransform = AdaptTransforms<TransformStyleTypes>[];\n\n/**\n * @deprecated Please use `AnimatedStyle` type instead.\n */\nexport type AnimateStyle<S> = {\n  [K in keyof S]: K extends 'transform'\n    ? AnimatedTransform\n    : S[K] extends ReadonlyArray<any>\n    ? ReadonlyArray<AnimateStyle<S[K][0]>>\n    : S[K] extends object\n    ? AnimateStyle<S[K]>\n    : S[K] extends ColorValue | undefined\n    ? S[K] | number\n    : S[K] | SharedValue<AnimatableValue>;\n};\n\nexport type AnimatedStyle<S> = AnimateStyle<S>;\n\n// provided types can either be their original types (like backgroundColor: pink)\n// or inline shared values/derived values\ntype MaybeSharedValue<S> = {\n  [K in keyof S]: S[K] | Readonly<SharedValue<Extract<S[K], AnimatableValue>>>;\n};\n\nexport type StylesOrDefault<T> = 'style' extends keyof T\n  ? MaybeSharedValue<T['style']>\n  : Record<string, unknown>;\n\ntype EntryOrExitLayoutType =\n  | BaseAnimationBuilder\n  | typeof BaseAnimationBuilder\n  | EntryExitAnimationFunction\n  | ReanimatedKeyframe;\n\n/* \n  Style type properties (properties that extends StyleProp<ViewStyle>)\n  can be defined with other property names than \"style\". For example `contentContainerStyle` in FlatList.\n  Type definition for all style type properties should act similarly, hence we\n  pick keys with 'Style' substring with the use of this utility type.\n*/\ntype PickStyleProps<T> = Pick<\n  T,\n  {\n    [Key in keyof T]-?: Key extends `${string}Style` ? Key : never;\n  }[keyof T]\n>;\n\ntype StyleAnimatedProps<P extends object> = {\n  [K in keyof PickStyleProps<P>]: StyleProp<\n    AnimatedStyle<P[K] | MaybeSharedValue<P[K]>>\n  >;\n};\n\ntype JustStyleAnimatedProp<P extends object> = {\n  style?: StyleProp<AnimatedStyle<StylesOrDefault<P>>>;\n};\n\ntype NonStyleAnimatedProps<P extends object> = {\n  [K in keyof Omit<P, keyof PickStyleProps<P> | 'style'>]:\n    | P[K]\n    | SharedValue<P[K]>;\n};\n\ntype LayoutProps = {\n  layout?:\n    | BaseAnimationBuilder\n    | LayoutAnimationFunction\n    | typeof BaseAnimationBuilder;\n  entering?: EntryOrExitLayoutType;\n  exiting?: EntryOrExitLayoutType;\n};\n\ntype SharedTransitionProps = {\n  sharedTransitionTag?: string;\n  sharedTransitionStyle?: SharedTransition;\n};\n\ntype AnimatedPropsProp<P extends object> = NonStyleAnimatedProps<P> &\n  JustStyleAnimatedProp<P> &\n  StyleAnimatedProps<P> &\n  LayoutProps &\n  SharedTransitionProps;\n\nexport type AnimateProps<P extends object> = NonStyleAnimatedProps<P> &\n  JustStyleAnimatedProp<P> &\n  StyleAnimatedProps<P> &\n  LayoutProps &\n  SharedTransitionProps & {\n    animatedProps?: Partial<AnimatedPropsProp<P>>;\n  };\n\n// ts-prune-ignore-next This will be used soon\nexport type AnimatedProps<P extends object> = AnimateProps<P>;\n\nexport type AnimatedPropsAdapterFunction = (\n  props: Record<string, unknown>\n) => void;\n\nexport type useAnimatedPropsType = <T extends object>(\n  updater: () => Partial<T>,\n  deps?: DependencyList | null,\n  adapters?:\n    | AnimatedPropsAdapterFunction\n    | AnimatedPropsAdapterFunction[]\n    | null\n) => Partial<T>;\n"],"mappings":""}